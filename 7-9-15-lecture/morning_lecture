Agile

Able to move quickly and easily, method of project management characterized by division of tasks into short phases of work and frequent reassessment and adaptaion of plans.

Let's talk about manufacturing.  Raw materials?  Not necessary.  Original concepts of manufacturing software were based on physical manufacturing.  Ridiculous.

Waterfall development process is the strawman as the opposition to agile except no one has ever used it.  Requirements(Product requirements document) >>  Design(Software architecture) >>  Implementation(Software)  >>  Verification  >>  Maintenance.  How could you possibly design the entire thing berfore you start working on it?  You can't because there are a lot of unknowns.  Back to the manufacturing process because then we needed "raw materials".  Waterfall was described in the paper from 1974 as a process.  The original software projects from the 50s and 60s used this.

A bunch of dudes and a couple of women got into a room and figured out what they would rather focus on with software projects rather than what was happening.  The things on the right were things they kept doing with big corporations and the things on the left are things they'd rather do and found more effective.

We are uncovering better ways of developing
software by doing it and helping others do it.
Through this work we have come to value:

Individuals and interactions                            over processes and tools
Working software                                        over comprehensive documentation
Customer collaboration                                  over contract negotiation
Responding to change                                    over following a plan

That is, while there is value in the items on
the right, we value the items on the left more.

Sharif had 10,000 pages of documentation on a government project before they started.  Wanted something less process heavy that they could actually rely on.

How?  

  Speed up the cycle.  Flight information display systems.  Gave them requirements, said see you in six months.  Derek's team wanted to work with his customers rather than have a deadline, ask them how something looked and tweak things with more frequent releases.  Becomes a little bit more expensive to fix things.  "Software bugs are more expensive to fix at the end but not as expensive as previously stated."

  Development cycles are often called "sprints".

  Communicate, talk to the customer and talk to your team

  Standups, communicate within the team.

  Retrospectives: at the end of a release, usually not at the end of every sprint talk about what worked and didn't work.  We'll have a retrospective tomorrow as a team and as a cohort.  Literally the same as when Derek worked at Sony.  Worked on a project, X-Factor, 18000+ requests per second, did smiley faces on the baord.

  How do we do this right now?

    Kanban boards!  To do, doing, done.  Literally post-it notes.  To do, doing and done.  If you're doing something, move it over.  They usually describe a feature of some sort.  One of the reasons it works is because it is so simple.  The colors can mean something but don't have to.  Color coding is a process thing, doesn't want to include too much process.  Walt mentioned JIRA.  Can measure the velocity of the team.  JIRA has all this shit added on, added on process but is supposed to be easily manipulatable and easily changeable.

    Where can we find a stack of post it notes?

    Looking at the Kanban board, different people are doing different features.  So, how should we divide up work?

    Someone could work on the actual tweet model, someone could work on the controller, someone could work on the front end.

    Horizontal slices aren't great; don't divide up work between segregated interfaces.  So how should we actually divide up work.  Same graphic, instead we work on something like this.  One dude works on a feature that does all three things while completing one feature.  Don't have to ask someone can you write me a model to do this.  Same with other team members.

    How do we avoid conflicts?
    Horizontal was easy because you're working in different files but could all be in the same file.  Talk, git, push up and pull all the time.  If someone is working on something when their feature is done, push.  DOn't tell someone to push up when not done.  Should be pulling all the time to avoid merge conflicts.  Happens if you don't pull code down enough times.  Don't say, I'm working on this file, no one else touch it.  It might be it won't show up as often as you'd hope.  You could also have 7 different controller files: users controller, tweets controller.  Can still sort of do, with one person, all the features of related to one thing.

    This might be obvious to everyone else at this point.  Aaron, Marshall and Tim on a team.  Three separate features.  Just picked three.  Aaron finished a feature.  He would push it up.  Pull early and often.  Lets say an hour passes and another pushes, must pull again before someone pushes.

    Must also send a pull request so that the person who forked it must also review a pull request.  Won't let you click the green button until you can merge correctly.  So we should be merging or the pulls won't do anything.

    Derek: different defense contractor, built a feature before he left a giant corporation.  It took him a few months.  His boss, after he left, merged stuff using subversion and the branches in subversion would clone the entire thing.  Boss waited until Derek left to do it.  Recommends respecting your teammates enough to let them pull things in.  If the person you hired to write code can't code, then why did you hire them?

    When you pull before you push, do you merge it locally?  Yes!

    Marshall: What the fuck is a partial?  Can that be a good way of avoiding merge conflicts?  Avoids having massive files.  That helps avoid everyone editing everything at the same time.

    Bikram: Sprints.  Are they usually two weeks?  Whatever you want.  More like a check point of what you're doing, ideally all the things you want to do will get done when the sprint is over.